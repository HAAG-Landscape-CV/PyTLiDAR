"""
Python adaptation and extension of TREEQSM:

Generate two orthonormal vectors based on a given axis.


% -----------------------------------------------------------
% This file is part of TREEQSM.
%
% TREEQSM is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% TREEQSM is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with TREEQSM.  If not, see <http://www.gnu.org/licenses/>.
% -----------------------------------------------------------


Version: 0.0.1
Date: 18 Jan 2025
Authors: Fan Yang, John Hagood, Amir Hossein Alikhah Mishamandani
Copyright (C) 2025 Georgia Institute of Technology Human-Augmented Analytics Group

This derivative work is released under the GNU General Public License (GPL).
"""

import numpy as np

import numpy as np
from numba import jit

@jit
def orthonormal_vectors(U):
    """
    Generate two unit vectors (V and W) that are orthogonal to each other
    and to the input vector U.
    """
    # Generate a random vector V
    V = np.random.rand(3)
    # keeping vector same as vector generated by matlab for now: 
    # V = np.array([0.223505555240651,0.942321673912143,0.504261406484429])
    

    # Compute cross product with U to get an orthogonal vector
    V = np.cross(V, U)

    # Ensure V is a valid non-zero vector
    while np.linalg.norm(V) == 0:
        V = np.random.rand(3)
        V = np.cross(V, U)

    # Compute the second orthogonal vector W
    W = np.cross(V, U)

    # Normalize both vectors
    V /= np.linalg.norm(V)
    W /= np.linalg.norm(W)

    return V, W

"""
def orthonormal_vectors(axis):
    axis = np.array(axis) / np.linalg.norm(axis)
    if abs(axis[0]) < abs(axis[1]):
        temp = np.array([1, 0, 0])
    else:
        temp = np.array([0, 1, 0])

    u = np.cross(axis, temp)
    u /= np.linalg.norm(u)
    w = np.cross(axis, u)
    w /= np.linalg.norm(w)

    return u, w
"""